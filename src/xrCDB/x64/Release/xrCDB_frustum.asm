; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?resize@?$svector@U?$_vector3@M@@$0DA@@@QEAAXH@Z ; svector<_vector3<float>,48>::resize
PUBLIC	?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z	; frustum_collider<0,0>::_prim
PUBLIC	?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ; frustum_collider<0,0>::_box
PUBLIC	?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z	; frustum_collider<0,1>::_prim
PUBLIC	?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ; frustum_collider<0,1>::_box
PUBLIC	?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z	; frustum_collider<1,0>::_prim
PUBLIC	?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ; frustum_collider<1,0>::_box
PUBLIC	?_prim@?$frustum_collider@$00$00@@QEAAXK@Z	; frustum_collider<1,1>::_prim
PUBLIC	?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ; frustum_collider<1,1>::_box
PUBLIC	?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,0>::_stab
PUBLIC	?_init@?$frustum_collider@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ; frustum_collider<0,0>::_init
PUBLIC	?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,1>::_stab
PUBLIC	?_init@?$frustum_collider@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ; frustum_collider<0,1>::_init
PUBLIC	?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,0>::_stab
PUBLIC	?_init@?$frustum_collider@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ; frustum_collider<1,0>::_init
PUBLIC	?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,1>::_stab
PUBLIC	?_init@?$frustum_collider@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ; frustum_collider<1,1>::_init
PUBLIC	?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z ; CDB::COLLIDER::frustum_query
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z DD imagerel $LN79
	DD	imagerel $LN79+194
	DD	imagerel $unwind$?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z DD imagerel $LN79
	DD	imagerel $LN79+194
	DD	imagerel $unwind$?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z DD imagerel $LN79
	DD	imagerel $LN79+180
	DD	imagerel $unwind$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z DD imagerel $LN79+180
	DD	imagerel $LN79+355
	DD	imagerel $chain$0$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z DD imagerel $LN79+355
	DD	imagerel $LN79+376
	DD	imagerel $chain$1$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z DD imagerel $LN79
	DD	imagerel $LN79+180
	DD	imagerel $unwind$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z DD imagerel $LN79+180
	DD	imagerel $LN79+355
	DD	imagerel $chain$0$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z DD imagerel $LN79+355
	DD	imagerel $LN79+376
	DD	imagerel $chain$1$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN36
	DD	imagerel $LN36+353
	DD	imagerel $unwind$?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN44
	DD	imagerel $LN44+134
	DD	imagerel $unwind$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN44+134
	DD	imagerel $LN44+379
	DD	imagerel $chain$0$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN44+379
	DD	imagerel $LN44+395
	DD	imagerel $chain$1$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN36
	DD	imagerel $LN36+353
	DD	imagerel $unwind$?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN44
	DD	imagerel $LN44+134
	DD	imagerel $unwind$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN44+134
	DD	imagerel $LN44+379
	DD	imagerel $chain$0$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN44+379
	DD	imagerel $LN44+395
	DD	imagerel $chain$1$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD imagerel $LN132
	DD	imagerel $LN132+236
	DD	imagerel $unwind$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+134
	DD	imagerel $unwind$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 020521H
	DD	0c6405H
	DD	imagerel $LN44
	DD	imagerel $LN44+134
	DD	imagerel $unwind$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 061e01H
	DD	04681eH
	DD	0d3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 061e01H
	DD	04681eH
	DD	0c3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+134
	DD	imagerel $unwind$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 020521H
	DD	0c6405H
	DD	imagerel $LN44
	DD	imagerel $LN44+134
	DD	imagerel $unwind$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 061e01H
	DD	04681eH
	DD	0d3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 061e01H
	DD	04681eH
	DD	0c3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD 031e01H
	DD	04681eH
	DD	0a207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN79
	DD	imagerel $LN79+180
	DD	imagerel $unwind$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z DD 020821H
	DD	0a23408H
	DD	imagerel $LN79
	DD	imagerel $LN79+180
	DD	imagerel $unwind$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z DD 071301H
	DD	0a46413H
	DD	0a35413H
	DD	0a00113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD 031e01H
	DD	04681eH
	DD	0a207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN79
	DD	imagerel $LN79+180
	DD	imagerel $unwind$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z DD 020821H
	DD	0a23408H
	DD	imagerel $LN79
	DD	imagerel $LN79+180
	DD	imagerel $unwind$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z DD 071301H
	DD	0a46413H
	DD	0a35413H
	DD	0a00113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD 031e01H
	DD	04681eH
	DD	0a207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z DD 061001H
	DD	0f6410H
	DD	0e3410H
	DD	0700cb210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD 031e01H
	DD	04681eH
	DD	0a207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z DD 061001H
	DD	0f6410H
	DD	0e3410H
	DD	0700cb210H
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.h
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\frustum.h
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\x-ray\stcop\rgs\src\xrcdb\frustum.h
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\frustum.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
_TEXT	SEGMENT
BC$1 = 32
BC$2 = 32
this$ = 80
m_def$ = 88
F$ = 96
?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z PROC ; CDB::COLLIDER::frustum_query, COMDAT

; 81   : {

$LN132:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.h

; 86   : 			if (S_READY!=status)

	cmp	DWORD PTR [rdx+16], 0
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 81   : {

	mov	rsi, r8
	mov	rbx, rdx
	mov	rdi, rcx
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.h

; 86   : 			if (S_READY!=status)

	je	SHORT $LN9@frustum_qu

; 87   : 			{
; 88   : 				Log						("! WARNING: syncronized CDB::query");
; 89   : 				xrCriticalSection*	C	= (xrCriticalSection*) &cs;
; 90   : 				C->Enter				();

	mov	rcx, rdx
	call	QWORD PTR __imp_?Enter@xrCriticalSection@@QEAAXXZ

; 91   : 				C->Leave				();

	mov	rcx, rbx
	call	QWORD PTR __imp_?Leave@xrCriticalSection@@QEAAXXZ
$LN9@frustum_qu:
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 150  : 		IMPLEMENT_COLLISION_TREE(AABBNoLeafTree, AABBNoLeafNode)

	mov	rax, QWORD PTR [rbx+8]
; File c:\x-ray\stcop\rgs\src\xrcdb\frustum.h

; 82   : 	u32				getMask				() const { return (1<<p_count)-1; }

	mov	ecx, DWORD PTR [rsi+240]
	mov	r8d, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 150  : 		IMPLEMENT_COLLISION_TREE(AABBNoLeafTree, AABBNoLeafNode)

	mov	r9, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rdi+16]
; File c:\x-ray\stcop\rgs\src\xrcdb\frustum.h

; 82   : 	u32				getMask				() const { return (1<<p_count)-1; }

	shl	r8d, cl
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 150  : 		IMPLEMENT_COLLISION_TREE(AABBNoLeafTree, AABBNoLeafNode)

	mov	rdx, QWORD PTR [r9+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	QWORD PTR [rdi+24], rax
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 91   : 	if (frustum_mode&OPT_FULL_TEST) 

	mov	eax, DWORD PTR [rdi+8]
; File c:\x-ray\stcop\rgs\src\xrcdb\frustum.h

; 82   : 	u32				getMask				() const { return (1<<p_count)-1; }

	dec	r8d
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 22   : 		dest		= CL;

	mov	QWORD PTR BC$2[rsp], rdi

; 25   : 		F			= _F;

	mov	QWORD PTR BC$2[rsp+24], rsi

; 94   : 		{
; 95   : 			frustum_collider<true,true> BC;
; 96   : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 97   : 			BC._stab	(N,mask);

	lea	rcx, QWORD PTR BC$2[rsp]
	test	al, 8
	je	SHORT $LN6@frustum_qu

; 92   : 	{
; 93   : 		if (frustum_mode&OPT_ONLYFIRST)

	test	al, 2

; 23   : 		tris		= T;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR BC$2[rsp+8], rax

; 24   : 		verts		= V;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR BC$2[rsp+16], rax

; 92   : 	{
; 93   : 		if (frustum_mode&OPT_ONLYFIRST)

	je	SHORT $LN5@frustum_qu

; 94   : 		{
; 95   : 			frustum_collider<true,true> BC;
; 96   : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 97   : 			BC._stab	(N,mask);

	call	?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,1>::_stab

; 113  : 		}
; 114  : 	}
; 115  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN5@frustum_qu:

; 98   : 		} else {
; 99   : 			frustum_collider<true,false> BC;
; 100  : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 101  : 			BC._stab	(N,mask);

	call	?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,0>::_stab

; 113  : 		}
; 114  : 	}
; 115  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN6@frustum_qu:

; 102  : 		}
; 103  : 	} else {
; 104  : 		if (frustum_mode&OPT_ONLYFIRST)

	test	al, 2

; 23   : 		tris		= T;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR BC$1[rsp+8], rax

; 24   : 		verts		= V;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR BC$1[rsp+16], rax

; 102  : 		}
; 103  : 	} else {
; 104  : 		if (frustum_mode&OPT_ONLYFIRST)

	je	SHORT $LN2@frustum_qu

; 105  : 		{
; 106  : 			frustum_collider<false,true> BC;
; 107  : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 108  : 			BC._stab	(N,mask);

	call	?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,1>::_stab

; 113  : 		}
; 114  : 	}
; 115  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN2@frustum_qu:

; 109  : 		} else {
; 110  : 			frustum_collider<false,false> BC;
; 111  : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 112  : 			BC._stab	(N,mask);

	call	?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,0>::_stab

; 113  : 		}
; 114  : 	}
; 115  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z ENDP ; CDB::COLLIDER::frustum_query
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_init@?$frustum_collider@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
_F$ = 40
?_init@?$frustum_collider@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z PROC ; frustum_collider<1,1>::_init, COMDAT

; 22   : 		dest		= CL;
; 23   : 		tris		= T;
; 24   : 		verts		= V;
; 25   : 		F			= _F;

	mov	rax, QWORD PTR _F$[rsp]
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r9
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+16], r8

; 26   : 	}

	ret	0
?_init@?$frustum_collider@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ENDP ; frustum_collider<1,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
_TEXT	SEGMENT
mM$1 = 32
this$ = 96
node$ = 104
mask$ = 112
?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z PROC ; frustum_collider<1,1>::_stab, COMDAT

; 62   : 	{

$LN44:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	DWORD PTR [rax+24], r8d
	push	rdi
	sub	rsp, 80					; 00000050H
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 62   : 	{

	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]

; 62   : 	{

	mov	rbx, rdx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR [rax+24]
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rdx]
	movaps	xmm0, xmm6

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rdx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm0, DWORD PTR [rdx+12]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-44], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rdx+16]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rdx+20]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-36], xmm3
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	je	$LN1@stab
	mov	QWORD PTR [rsp+96], rsi
	mov	rsi, 5270498306774157605		; 4924924924924925H
	npad	11
$LL33@stab:
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$frustum_collider@$00$00@@QEAAXK@Z ; frustum_collider<1,1>::_prim

; 69   : 		else					_stab	(node->GetPos(),mask);

	jmp	SHORT $LN4@stab
$LN5@stab:
	mov	r8d, DWORD PTR mask$[rsp]
	call	?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,1>::_stab
$LN4@stab:
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.h

; 154  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	mov	rax, rsi
	imul	rcx
	sar	rdx, 4
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 72   : 		if (bFirst && dest->r_count())												return;

	test	edx, edx
	jne	$LN42@stab
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	SHORT $LN38@stab

; 76   : 		else					_stab	(node->GetNeg(),mask);

	mov	rbx, QWORD PTR [rbx+32]

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rdi+24]
	lea	r8, QWORD PTR mask$[rsp]
	lea	rdx, QWORD PTR mM$1[rsp]
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rbx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+12], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rbx+16]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+4], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+16], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rbx+20]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+8], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+20], xmm3
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	jne	$LL33@stab
	jmp	SHORT $LN42@stab
$LN38@stab:
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$frustum_collider@$00$00@@QEAAXK@Z ; frustum_collider<1,1>::_prim
$LN42@stab:
	mov	rsi, QWORD PTR [rsp+96]
$LN1@stab:

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+104]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ENDP ; frustum_collider<1,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_init@?$frustum_collider@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
_F$ = 40
?_init@?$frustum_collider@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z PROC ; frustum_collider<1,0>::_init, COMDAT

; 22   : 		dest		= CL;
; 23   : 		tris		= T;
; 24   : 		verts		= V;
; 25   : 		F			= _F;

	mov	rax, QWORD PTR _F$[rsp]
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r9
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+16], r8

; 26   : 	}

	ret	0
?_init@?$frustum_collider@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ENDP ; frustum_collider<1,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
_TEXT	SEGMENT
mM$1 = 32
this$ = 96
node$ = 104
mask$ = 112
?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z PROC ; frustum_collider<1,0>::_stab, COMDAT

; 62   : 	{

$LN36:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	DWORD PTR [rax+24], r8d
	push	rdi
	sub	rsp, 80					; 00000050H
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 62   : 	{

	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]

; 62   : 	{

	mov	rbx, rdx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR [rax+24]
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rdx]
	movaps	xmm0, xmm6

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rdx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm0, DWORD PTR [rdx+12]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-44], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rdx+16]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rdx+20]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-36], xmm3
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	je	$LN1@stab
	npad	10
$LL27@stab:
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z ; frustum_collider<1,0>::_prim

; 69   : 		else					_stab	(node->GetPos(),mask);

	jmp	SHORT $LN4@stab
$LN5@stab:
	mov	r8d, DWORD PTR mask$[rsp]
	call	?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,0>::_stab
$LN4@stab:
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN31@stab

; 76   : 		else					_stab	(node->GetNeg(),mask);

	mov	rbx, QWORD PTR [rbx+32]

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rdi+24]
	lea	r8, QWORD PTR mask$[rsp]
	lea	rdx, QWORD PTR mM$1[rsp]
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rbx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+12], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rbx+16]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+4], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+16], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rbx+20]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+8], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+20], xmm3
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	jne	$LL27@stab

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN31@stab:
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z ; frustum_collider<1,0>::_prim
$LN1@stab:

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ENDP ; frustum_collider<1,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_init@?$frustum_collider@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
_F$ = 40
?_init@?$frustum_collider@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z PROC ; frustum_collider<0,1>::_init, COMDAT

; 22   : 		dest		= CL;
; 23   : 		tris		= T;
; 24   : 		verts		= V;
; 25   : 		F			= _F;

	mov	rax, QWORD PTR _F$[rsp]
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r9
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+16], r8

; 26   : 	}

	ret	0
?_init@?$frustum_collider@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ENDP ; frustum_collider<0,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
_TEXT	SEGMENT
mM$1 = 32
this$ = 96
node$ = 104
mask$ = 112
?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z PROC ; frustum_collider<0,1>::_stab, COMDAT

; 62   : 	{

$LN44:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	DWORD PTR [rax+24], r8d
	push	rdi
	sub	rsp, 80					; 00000050H
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 62   : 	{

	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]

; 62   : 	{

	mov	rbx, rdx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR [rax+24]
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rdx]
	movaps	xmm0, xmm6

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rdx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm0, DWORD PTR [rdx+12]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-44], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rdx+16]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rdx+20]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-36], xmm3
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	je	$LN1@stab
	mov	QWORD PTR [rsp+96], rsi
	mov	rsi, 5270498306774157605		; 4924924924924925H
	npad	11
$LL33@stab:
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z ; frustum_collider<0,1>::_prim

; 69   : 		else					_stab	(node->GetPos(),mask);

	jmp	SHORT $LN4@stab
$LN5@stab:
	mov	r8d, DWORD PTR mask$[rsp]
	call	?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,1>::_stab
$LN4@stab:
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.h

; 154  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	mov	rax, rsi
	imul	rcx
	sar	rdx, 4
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 72   : 		if (bFirst && dest->r_count())												return;

	test	edx, edx
	jne	$LN42@stab
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	SHORT $LN38@stab

; 76   : 		else					_stab	(node->GetNeg(),mask);

	mov	rbx, QWORD PTR [rbx+32]

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rdi+24]
	lea	r8, QWORD PTR mask$[rsp]
	lea	rdx, QWORD PTR mM$1[rsp]
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rbx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+12], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rbx+16]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+4], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+16], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rbx+20]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+8], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+20], xmm3
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	jne	$LL33@stab
	jmp	SHORT $LN42@stab
$LN38@stab:
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z ; frustum_collider<0,1>::_prim
$LN42@stab:
	mov	rsi, QWORD PTR [rsp+96]
$LN1@stab:

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+104]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ENDP ; frustum_collider<0,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_init@?$frustum_collider@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
_F$ = 40
?_init@?$frustum_collider@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z PROC ; frustum_collider<0,0>::_init, COMDAT

; 22   : 		dest		= CL;
; 23   : 		tris		= T;
; 24   : 		verts		= V;
; 25   : 		F			= _F;

	mov	rax, QWORD PTR _F$[rsp]
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r9
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+16], r8

; 26   : 	}

	ret	0
?_init@?$frustum_collider@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ENDP ; frustum_collider<0,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
_TEXT	SEGMENT
mM$1 = 32
this$ = 96
node$ = 104
mask$ = 112
?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z PROC ; frustum_collider<0,0>::_stab, COMDAT

; 62   : 	{

$LN36:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	DWORD PTR [rax+24], r8d
	push	rdi
	sub	rsp, 80					; 00000050H
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 62   : 	{

	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]

; 62   : 	{

	mov	rbx, rdx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR [rax+24]
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rdx]
	movaps	xmm0, xmm6

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rdx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm0, DWORD PTR [rdx+12]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-44], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rdx+16]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rdx+20]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-36], xmm3
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	je	$LN1@stab
	npad	10
$LL27@stab:
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z ; frustum_collider<0,0>::_prim

; 69   : 		else					_stab	(node->GetPos(),mask);

	jmp	SHORT $LN4@stab
$LN5@stab:
	mov	r8d, DWORD PTR mask$[rsp]
	call	?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,0>::_stab
$LN4@stab:
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN31@stab

; 76   : 		else					_stab	(node->GetNeg(),mask);

	mov	rbx, QWORD PTR [rbx+32]

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rdi+24]
	lea	r8, QWORD PTR mask$[rsp]
	lea	rdx, QWORD PTR mM$1[rsp]
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rbx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+12], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rbx+16]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+4], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+16], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rbx+20]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+8], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+20], xmm3
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	jne	$LL27@stab

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN31@stab:
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\x-ray\stcop\rgs\src\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z ; frustum_collider<0,0>::_prim
$LN1@stab:

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ENDP ; frustum_collider<0,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
_TEXT	SEGMENT
this$ = 96
C$ = 104
E$ = 112
mask$ = 120
?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z PROC ; frustum_collider<1,1>::_box, COMDAT

; 28   : 	{

$LN8:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movss	xmm4, DWORD PTR [r8+4]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm2, DWORD PTR [r8+8]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
	mov	r8, r9
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm0, xmm6

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-44], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm2, xmm1
	movss	DWORD PTR [rax-36], xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 33   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ENDP ; frustum_collider<1,1>::_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\fixedvector.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_prim@?$frustum_collider@$00$00@@QEAAXK@Z
_TEXT	SEGMENT
$T1 = 32
src$2 = 96
dst$3 = 688
this$ = 1296
prim$ = 1304
?_prim@?$frustum_collider@$00$00@@QEAAXK@Z PROC		; frustum_collider<1,1>::_prim, COMDAT

; 35   : 	{

$LN79:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 1280				; 00000500H

; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];

	mov	r10, QWORD PTR [rcx+16]
	mov	r9, QWORD PTR [rcx+8]
; File c:\x-ray\stcop\rgs\src\xrcore\fixedvector.h

; 34   :     IC void resize(int c) { VERIFY(c <= dim); count = c; }

	mov	DWORD PTR [rax-616], 3

; 22   :     {}

	mov	DWORD PTR [rax-24], 0
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];

	mov	esi, edx
	mov	rdi, rcx
	shl	rsi, 4
	mov	ebp, edx

; 40   : 			src[1]		= verts[ tris[prim].verts[1] ];
; 41   : 			src[2]		= verts[ tris[prim].verts[2] ];
; 42   : 			if (F->ClipPoly(src,dst))

	lea	rdx, QWORD PTR src$2[rsp]
	mov	eax, DWORD PTR [r9+rsi]
	lea	r8, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r10+r8*4]
	movsdx	QWORD PTR src$2[rsp], xmm0
	mov	eax, DWORD PTR [r10+r8*4+8]
	lea	r8, QWORD PTR dst$3[rsp]
	mov	DWORD PTR src$2[rsp+8], eax
	mov	eax, DWORD PTR [r9+rsi+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r10+rcx*4]
	movsdx	QWORD PTR src$2[rsp+12], xmm0
	mov	eax, DWORD PTR [r10+rcx*4+8]
	mov	DWORD PTR src$2[rsp+20], eax
	mov	eax, DWORD PTR [r9+rsi+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r10+rcx*4]
	movsdx	QWORD PTR src$2[rsp+24], xmm0
	mov	eax, DWORD PTR [r10+rcx*4+8]
	mov	rcx, QWORD PTR [rdi+24]
	mov	DWORD PTR src$2[rsp+32], eax
	call	?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z ; CFrustum::ClipPoly
	test	rax, rax
	je	$LN2@prim
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp

; 186  : 	rd.push_back		(RESULT());

	xor	eax, eax
	mov	QWORD PTR [rsp+1296], rbx
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 44   : 				RESULT& R	= dest->r_add();

	mov	rbx, QWORD PTR [rdi]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp

; 186  : 	rd.push_back		(RESULT());

	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR $T1[rsp], rax
	mov	QWORD PTR $T1[rsp+8], rax
	mov	QWORD PTR $T1[rsp+16], rax
	mov	QWORD PTR $T1[rsp+24], rax
	mov	QWORD PTR $T1[rsp+32], rax
	mov	QWORD PTR $T1[rsp+40], rax
	mov	QWORD PTR $T1[rsp+48], rax
	call	?push_back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAX$$QEAURESULT@CDB@@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::push_back
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	r9, QWORD PTR [rbx+24]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 46   : 				R.verts[0]	= verts[ tris[prim].verts[0] ];

	mov	rdx, QWORD PTR [rdi+16]
	mov	r8, QWORD PTR [rdi+8]
	mov	rbx, QWORD PTR [rsp+1296]
	mov	DWORD PTR [r9-16], ebp
	add	r8, rsi
	mov	eax, DWORD PTR [r8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [rdx+rcx*4]
	movsdx	QWORD PTR [r9-56], xmm0
	mov	eax, DWORD PTR [rdx+rcx*4+8]
	mov	DWORD PTR [r9-48], eax

; 47   : 				R.verts[1]	= verts[ tris[prim].verts[1] ];

	mov	eax, DWORD PTR [r8+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [rdx+rcx*4]
	movsdx	QWORD PTR [r9-44], xmm0
	mov	eax, DWORD PTR [rdx+rcx*4+8]
	mov	DWORD PTR [r9-36], eax

; 48   : 				R.verts[2]	= verts[ tris[prim].verts[2] ];

	mov	eax, DWORD PTR [r8+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [rdx+rcx*4]
	movsdx	QWORD PTR [r9-32], xmm0
	mov	eax, DWORD PTR [rdx+rcx*4+8]
	mov	DWORD PTR [r9-24], eax

; 49   : 				R.dummy		= tris[prim].dummy;

	mov	eax, DWORD PTR [r8+12]
	mov	DWORD PTR [r9-20], eax
$LN2@prim:

; 50   : 			}
; 51   : 		} else {
; 52   : 			RESULT& R	= dest->r_add();
; 53   : 			R.id		= prim;
; 54   : 			R.verts[0]	= verts[ tris[prim].verts[0] ];
; 55   : 			R.verts[1]	= verts[ tris[prim].verts[1] ];
; 56   : 			R.verts[2]	= verts[ tris[prim].verts[2] ];
; 57   : 			R.dummy		= tris[prim].dummy;
; 58   : 		}
; 59   : 	}

	lea	r11, QWORD PTR [rsp+1280]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$frustum_collider@$00$00@@QEAAXK@Z ENDP		; frustum_collider<1,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
_TEXT	SEGMENT
this$ = 96
C$ = 104
E$ = 112
mask$ = 120
?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z PROC ; frustum_collider<1,0>::_box, COMDAT

; 28   : 	{

$LN8:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movss	xmm4, DWORD PTR [r8+4]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm2, DWORD PTR [r8+8]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
	mov	r8, r9
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm0, xmm6

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-44], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm2, xmm1
	movss	DWORD PTR [rax-36], xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 33   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ENDP ; frustum_collider<1,0>::_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\fixedvector.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z
_TEXT	SEGMENT
$T1 = 32
src$2 = 96
dst$3 = 688
this$ = 1296
prim$ = 1304
?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z PROC	; frustum_collider<1,0>::_prim, COMDAT

; 35   : 	{

$LN79:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 1280				; 00000500H

; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];

	mov	r10, QWORD PTR [rcx+16]
	mov	r9, QWORD PTR [rcx+8]
; File c:\x-ray\stcop\rgs\src\xrcore\fixedvector.h

; 34   :     IC void resize(int c) { VERIFY(c <= dim); count = c; }

	mov	DWORD PTR [rax-616], 3

; 22   :     {}

	mov	DWORD PTR [rax-24], 0
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];

	mov	esi, edx
	mov	rdi, rcx
	shl	rsi, 4
	mov	ebp, edx

; 40   : 			src[1]		= verts[ tris[prim].verts[1] ];
; 41   : 			src[2]		= verts[ tris[prim].verts[2] ];
; 42   : 			if (F->ClipPoly(src,dst))

	lea	rdx, QWORD PTR src$2[rsp]
	mov	eax, DWORD PTR [r9+rsi]
	lea	r8, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r10+r8*4]
	movsdx	QWORD PTR src$2[rsp], xmm0
	mov	eax, DWORD PTR [r10+r8*4+8]
	lea	r8, QWORD PTR dst$3[rsp]
	mov	DWORD PTR src$2[rsp+8], eax
	mov	eax, DWORD PTR [r9+rsi+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r10+rcx*4]
	movsdx	QWORD PTR src$2[rsp+12], xmm0
	mov	eax, DWORD PTR [r10+rcx*4+8]
	mov	DWORD PTR src$2[rsp+20], eax
	mov	eax, DWORD PTR [r9+rsi+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r10+rcx*4]
	movsdx	QWORD PTR src$2[rsp+24], xmm0
	mov	eax, DWORD PTR [r10+rcx*4+8]
	mov	rcx, QWORD PTR [rdi+24]
	mov	DWORD PTR src$2[rsp+32], eax
	call	?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z ; CFrustum::ClipPoly
	test	rax, rax
	je	$LN2@prim
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp

; 186  : 	rd.push_back		(RESULT());

	xor	eax, eax
	mov	QWORD PTR [rsp+1296], rbx
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 44   : 				RESULT& R	= dest->r_add();

	mov	rbx, QWORD PTR [rdi]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp

; 186  : 	rd.push_back		(RESULT());

	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR $T1[rsp], rax
	mov	QWORD PTR $T1[rsp+8], rax
	mov	QWORD PTR $T1[rsp+16], rax
	mov	QWORD PTR $T1[rsp+24], rax
	mov	QWORD PTR $T1[rsp+32], rax
	mov	QWORD PTR $T1[rsp+40], rax
	mov	QWORD PTR $T1[rsp+48], rax
	call	?push_back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAX$$QEAURESULT@CDB@@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::push_back
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	r9, QWORD PTR [rbx+24]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 46   : 				R.verts[0]	= verts[ tris[prim].verts[0] ];

	mov	rdx, QWORD PTR [rdi+16]
	mov	r8, QWORD PTR [rdi+8]
	mov	rbx, QWORD PTR [rsp+1296]
	mov	DWORD PTR [r9-16], ebp
	add	r8, rsi
	mov	eax, DWORD PTR [r8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [rdx+rcx*4]
	movsdx	QWORD PTR [r9-56], xmm0
	mov	eax, DWORD PTR [rdx+rcx*4+8]
	mov	DWORD PTR [r9-48], eax

; 47   : 				R.verts[1]	= verts[ tris[prim].verts[1] ];

	mov	eax, DWORD PTR [r8+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [rdx+rcx*4]
	movsdx	QWORD PTR [r9-44], xmm0
	mov	eax, DWORD PTR [rdx+rcx*4+8]
	mov	DWORD PTR [r9-36], eax

; 48   : 				R.verts[2]	= verts[ tris[prim].verts[2] ];

	mov	eax, DWORD PTR [r8+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [rdx+rcx*4]
	movsdx	QWORD PTR [r9-32], xmm0
	mov	eax, DWORD PTR [rdx+rcx*4+8]
	mov	DWORD PTR [r9-24], eax

; 49   : 				R.dummy		= tris[prim].dummy;

	mov	eax, DWORD PTR [r8+12]
	mov	DWORD PTR [r9-20], eax
$LN2@prim:

; 50   : 			}
; 51   : 		} else {
; 52   : 			RESULT& R	= dest->r_add();
; 53   : 			R.id		= prim;
; 54   : 			R.verts[0]	= verts[ tris[prim].verts[0] ];
; 55   : 			R.verts[1]	= verts[ tris[prim].verts[1] ];
; 56   : 			R.verts[2]	= verts[ tris[prim].verts[2] ];
; 57   : 			R.dummy		= tris[prim].dummy;
; 58   : 		}
; 59   : 	}

	lea	r11, QWORD PTR [rsp+1280]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z ENDP	; frustum_collider<1,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
_TEXT	SEGMENT
this$ = 96
C$ = 104
E$ = 112
mask$ = 120
?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z PROC ; frustum_collider<0,1>::_box, COMDAT

; 28   : 	{

$LN8:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movss	xmm4, DWORD PTR [r8+4]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm2, DWORD PTR [r8+8]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
	mov	r8, r9
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm0, xmm6

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-44], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm2, xmm1
	movss	DWORD PTR [rax-36], xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 33   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ENDP ; frustum_collider<0,1>::_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z
_TEXT	SEGMENT
this$ = 112
prim$ = 120
?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z PROC	; frustum_collider<0,1>::_prim, COMDAT

; 35   : 	{

$LN79:
	mov	r11, rsp
	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+16], rsi
	push	rdi
	sub	rsp, 96					; 00000060H

; 36   : 		if (bClass3)	{
; 37   : 			sPoly		src,dst;
; 38   : 			src.resize	(3);
; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];
; 40   : 			src[1]		= verts[ tris[prim].verts[1] ];
; 41   : 			src[2]		= verts[ tris[prim].verts[2] ];
; 42   : 			if (F->ClipPoly(src,dst))
; 43   : 			{
; 44   : 				RESULT& R	= dest->r_add();
; 45   : 				R.id		= prim;
; 46   : 				R.verts[0]	= verts[ tris[prim].verts[0] ];
; 47   : 				R.verts[1]	= verts[ tris[prim].verts[1] ];
; 48   : 				R.verts[2]	= verts[ tris[prim].verts[2] ];
; 49   : 				R.dummy		= tris[prim].dummy;
; 50   : 			}
; 51   : 		} else {
; 52   : 			RESULT& R	= dest->r_add();

	mov	rbx, QWORD PTR [rcx]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp

; 186  : 	rd.push_back		(RESULT());

	xor	eax, eax
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 35   : 	{

	mov	edi, edx
	mov	rsi, rcx
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp

; 186  : 	rd.push_back		(RESULT());

	lea	rdx, QWORD PTR [r11-72]
	lea	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [r11-72], rax
	mov	QWORD PTR [r11-64], rax
	mov	QWORD PTR [r11-56], rax
	mov	QWORD PTR [r11-48], rax
	mov	QWORD PTR [r11-40], rax
	mov	QWORD PTR [r11-32], rax
	mov	QWORD PTR [r11-24], rax
	call	?push_back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAX$$QEAURESULT@CDB@@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::push_back
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	r9, QWORD PTR [rbx+24]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 54   : 			R.verts[0]	= verts[ tris[prim].verts[0] ];

	mov	rdx, QWORD PTR [rsi+16]

; 55   : 			R.verts[1]	= verts[ tris[prim].verts[1] ];
; 56   : 			R.verts[2]	= verts[ tris[prim].verts[2] ];
; 57   : 			R.dummy		= tris[prim].dummy;
; 58   : 		}
; 59   : 	}

	mov	rbx, QWORD PTR [rsp+112]
	mov	DWORD PTR [r9-16], edi
	mov	r8d, edi
	shl	r8, 4
	add	r8, QWORD PTR [rsi+8]
	mov	rsi, QWORD PTR [rsp+120]
	mov	eax, DWORD PTR [r8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [rdx+rcx*4]
	movsdx	QWORD PTR [r9-56], xmm0
	mov	eax, DWORD PTR [rdx+rcx*4+8]
	mov	DWORD PTR [r9-48], eax
	mov	eax, DWORD PTR [r8+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [rdx+rcx*4]
	movsdx	QWORD PTR [r9-44], xmm0
	mov	eax, DWORD PTR [rdx+rcx*4+8]
	mov	DWORD PTR [r9-36], eax
	mov	eax, DWORD PTR [r8+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [rdx+rcx*4]
	movsdx	QWORD PTR [r9-32], xmm0
	mov	eax, DWORD PTR [rdx+rcx*4+8]
	mov	DWORD PTR [r9-24], eax
	mov	eax, DWORD PTR [r8+12]
	mov	DWORD PTR [r9-20], eax
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z ENDP	; frustum_collider<0,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
_TEXT	SEGMENT
this$ = 96
C$ = 104
E$ = 112
mask$ = 120
?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z PROC ; frustum_collider<0,0>::_box, COMDAT

; 28   : 	{

$LN8:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movss	xmm4, DWORD PTR [r8+4]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm2, DWORD PTR [r8+8]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
	mov	r8, r9
; File c:\x-ray\stcop\rgs\src\xrcore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm0, xmm6

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-44], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm2, xmm1
	movss	DWORD PTR [rax-36], xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 33   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ENDP ; frustum_collider<0,0>::_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z
_TEXT	SEGMENT
this$ = 112
prim$ = 120
?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z PROC	; frustum_collider<0,0>::_prim, COMDAT

; 35   : 	{

$LN79:
	mov	r11, rsp
	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+16], rsi
	push	rdi
	sub	rsp, 96					; 00000060H

; 36   : 		if (bClass3)	{
; 37   : 			sPoly		src,dst;
; 38   : 			src.resize	(3);
; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];
; 40   : 			src[1]		= verts[ tris[prim].verts[1] ];
; 41   : 			src[2]		= verts[ tris[prim].verts[2] ];
; 42   : 			if (F->ClipPoly(src,dst))
; 43   : 			{
; 44   : 				RESULT& R	= dest->r_add();
; 45   : 				R.id		= prim;
; 46   : 				R.verts[0]	= verts[ tris[prim].verts[0] ];
; 47   : 				R.verts[1]	= verts[ tris[prim].verts[1] ];
; 48   : 				R.verts[2]	= verts[ tris[prim].verts[2] ];
; 49   : 				R.dummy		= tris[prim].dummy;
; 50   : 			}
; 51   : 		} else {
; 52   : 			RESULT& R	= dest->r_add();

	mov	rbx, QWORD PTR [rcx]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp

; 186  : 	rd.push_back		(RESULT());

	xor	eax, eax
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 35   : 	{

	mov	edi, edx
	mov	rsi, rcx
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb.cpp

; 186  : 	rd.push_back		(RESULT());

	lea	rdx, QWORD PTR [r11-72]
	lea	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [r11-72], rax
	mov	QWORD PTR [r11-64], rax
	mov	QWORD PTR [r11-56], rax
	mov	QWORD PTR [r11-48], rax
	mov	QWORD PTR [r11-40], rax
	mov	QWORD PTR [r11-32], rax
	mov	QWORD PTR [r11-24], rax
	call	?push_back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAX$$QEAURESULT@CDB@@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::push_back
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	r9, QWORD PTR [rbx+24]
; File c:\x-ray\stcop\rgs\src\xrcdb\xrcdb_frustum.cpp

; 54   : 			R.verts[0]	= verts[ tris[prim].verts[0] ];

	mov	rdx, QWORD PTR [rsi+16]

; 55   : 			R.verts[1]	= verts[ tris[prim].verts[1] ];
; 56   : 			R.verts[2]	= verts[ tris[prim].verts[2] ];
; 57   : 			R.dummy		= tris[prim].dummy;
; 58   : 		}
; 59   : 	}

	mov	rbx, QWORD PTR [rsp+112]
	mov	DWORD PTR [r9-16], edi
	mov	r8d, edi
	shl	r8, 4
	add	r8, QWORD PTR [rsi+8]
	mov	rsi, QWORD PTR [rsp+120]
	mov	eax, DWORD PTR [r8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [rdx+rcx*4]
	movsdx	QWORD PTR [r9-56], xmm0
	mov	eax, DWORD PTR [rdx+rcx*4+8]
	mov	DWORD PTR [r9-48], eax
	mov	eax, DWORD PTR [r8+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [rdx+rcx*4]
	movsdx	QWORD PTR [r9-44], xmm0
	mov	eax, DWORD PTR [rdx+rcx*4+8]
	mov	DWORD PTR [r9-36], eax
	mov	eax, DWORD PTR [r8+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [rdx+rcx*4]
	movsdx	QWORD PTR [r9-32], xmm0
	mov	eax, DWORD PTR [rdx+rcx*4+8]
	mov	DWORD PTR [r9-24], eax
	mov	eax, DWORD PTR [r8+12]
	mov	DWORD PTR [r9-20], eax
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z ENDP	; frustum_collider<0,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\x-ray\stcop\rgs\src\xrcore\fixedvector.h
;	COMDAT ?resize@?$svector@U?$_vector3@M@@$0DA@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
c$dead$ = 16
?resize@?$svector@U?$_vector3@M@@$0DA@@@QEAAXH@Z PROC	; svector<_vector3<float>,48>::resize, COMDAT

; 34   :     IC void resize(int c) { VERIFY(c <= dim); count = c; }

	mov	DWORD PTR [rcx+576], 3
	ret	0
?resize@?$svector@U?$_vector3@M@@$0DA@@@QEAAXH@Z ENDP	; svector<_vector3<float>,48>::resize
_TEXT	ENDS
END
